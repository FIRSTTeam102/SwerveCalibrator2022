plugins {
	id "cpp"
	id "google-test-test-suite"
	id "edu.wpi.first.GradleRIO" version "2022.4.1"
}

// nativeUtils.platformConfigs.named("linuxx86-64").configure {\
//     it.linker.args.add('-lstdc++fs') // links in C++ filesystem library
// }

tasks.register("writeSongsList") {
	// Find music files
	def songs  = []
	fileTree(include: ['*.chrp'], dir: "src/main/deploy/music").visit { FileVisitDetails details ->
		songs << details.file.name.take(details.file.name.lastIndexOf('.'))
	}

	// Create a new file
	new File(
		// Join project directory and deploy directory
		projectDir.toString() + "/src/main/deploy",
		// File name to write to
		"songs.txt"
	).text = songs.join('\n') // Set the contents of the file to the variable branch
}

// Define my targets (RoboRIO) and artifacts (deployable files)
// This is added by GradleRIO's backing project DeployTools.
deploy {
	targets {
		roborio(getTargetTypeClass('RoboRIO')) {
			// Team number is loaded either from the .wpilib/wpilib_preferences.json
			// or from command line. If not found an exception will be thrown.
			// You can use getTeamOrDefault(team) instead of getTeamNumber if you
			// want to store a team number in this file.
			team = project.frc.getTeamNumber()
			debug = project.frc.getDebugOrDefault(false)

			artifacts {
				// Add list of deployed songs
				writeSongsList

				// First part is artifact name, 2nd is artifact type
				// getTargetTypeClass is a shortcut to get the class type using a string

				frcCpp(getArtifactTypeClass('FRCNativeArtifact')) {
				}

				// Static files artifact
				frcStaticFileDeploy(getArtifactTypeClass('FileTreeArtifact')) {
					files = project.fileTree('src/main/deploy')
					directory = '/home/lvuser/deploy'
				}
			}
		}
	}
}

def deployArtifact = deploy.targets.roborio.artifacts.frcCpp

// Set this to true to include the src folder in the include directories passed
// to the compiler. Some eclipse project imports depend on this behavior.
// We recommend leaving this disabled if possible. Note for eclipse project
// imports this is enabled by default. For new projects, its disabled
def includeSrcInIncludeRoot = false

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DESKTOP
// Set this to true to enable desktop support.
def includeDesktopSupport = false

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DESKTOP

// Set to true to run simulation in debug mode
wpi.cpp.debugSimulation = false

// Default enable simgui
wpi.sim.addGui().defaultEnabled = true
// Enable DS but not by default
wpi.sim.addDriverstation()

model {
	components {
		frcUserProgram(NativeExecutableSpec) {
			targetPlatform wpi.platforms.roborio
			if (includeDesktopSupport) {
				targetPlatform wpi.platforms.desktop
			}

			sources.cpp {
				source {
					srcDir 'src/main/cpp'
					include '**/*.cpp', '**/*.cc'
				}
				exportedHeaders {
					srcDir 'src/main/include'
					if (includeSrcInIncludeRoot) {
						srcDir 'src/main/cpp'
					}
				}
			}

			// Set deploy task to deploy this component
			deployArtifact.component = it

			// Enable run tasks for this component
			wpi.cpp.enableExternalTasks(it)

			// Enable simulation for this component
			wpi.sim.enable(it)

			// Defining my dependencies. In this case, WPILib (+ friends), and vendor libraries.
			wpi.cpp.vendor.cpp(it)
			wpi.cpp.deps.wpilib(it)
		}
	}
	testSuites {
		frcUserProgramTest(GoogleTestTestSuiteSpec) {
			testing $.components.frcUserProgram

			sources.cpp {
				source {
					srcDir 'src/test/cpp'
					include '**/*.cpp'
				}
			}

			// Enable run tasks for this component
			wpi.cpp.enableExternalTasks(it)

			wpi.cpp.vendor.cpp(it)
			wpi.cpp.deps.wpilib(it)
			wpi.cpp.deps.googleTest(it)
		}
	}
}